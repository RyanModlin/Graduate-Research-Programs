# -*- coding: utf-8 -*-
"""Gillespie_Progesterone.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XTnirmGpThHXDyLGks1yBXAkeggo8qc4

#Abstract

The goal of the project is to model the steroid hormone biosynthesis pathway under different reaction conditions to identify ideal growth conditions to achieve a balance between progesterone production and cell health.

# Steroid Hormone Biosynthesis Pathway: Progesterone Production in Yeast

## Chemical Pathway

\begin{align}
&\text{Glucose} \; \xrightarrow{\; \sigma_1 \;} \; \text{Biomass} \xrightarrow{\; \sigma_2 \;} \text{Cell Death} \\
&\Big\downarrow \alpha \\
&\text{Ergosterol} \\
&\Big\downarrow \beta \\
&\text{Ergosta 5-enol} \; + \; \text{Ergosta 5,22-dienol} \\
&\Big\downarrow \gamma \\
&\text{Progenolone} \\
&\Big\downarrow \varphi \\
&\text{Progesterone}
\end{align}

## Chemical Reactions ($R_N$)

\begin{align}
&\textbf{R}_1 : c_{1,1}\text{ Glucose} \xrightarrow{\; \sigma_1 \;} c_{1,2}\text{ Biomass} \\
&\textbf{R}_2 : c_{2,1}\text{ Biomass} \xrightarrow{\; \sigma_2 \;} \emptyset \\
&\textbf{R}_3 : c_{3,1}\text{ Glucose} \xrightarrow{\; \alpha \;} c_{3,2}\text{ Ergosterol} \\
&\textbf{R}_4 : c_{4,1}\text{ Ergosterol} \xrightarrow{\; \beta \;} c_{4,2}\text{ Ergosta 5-enol} \; + \; c_{4,3}\text{ Ergosta 5,22-dienol}\\
&\textbf{R}_5 : c_{5,1}\text{ Ergosta 5-enol} \; + \; c_{5,2}\text{ Ergosta 5,22-dienol} \xrightarrow{\; \gamma \;} c_{5,3}\text{ Progenolone} \\
&\textbf{R}_6 : c_{6,1}\text{ Progenolone} \xrightarrow{\; \varphi \;} c_{6,2}\text{ Progesterone} \\
\text{where all  } c_{i,j} = 1
\end{align}

## Initial Molecular Concentrations

\begin{align}
  \vec{X}_0 &= \begin{bmatrix}
              \text{Glucose} \\
              \text{Biomass} \\
              \text{Ergosterol} \\
              \text{Ergost 5-enol} \\
              \text{Ergosta 5,22 dienol} \\
              \text{Progenolone} \\
              \text{Progesterone}
            \end{bmatrix} 
          = \begin{bmatrix}
              g \\
              b \\
              e \\
              e_5 \\
              e_{5,22} \\
              p \\
              p^*
            \end{bmatrix}
\end{align}

##Concentration Changes due to $R_N$ ($\Delta_M$)

\begin{align}
\Delta_1 = \begin{bmatrix}
                  -1 \\
                  +1 \\
                  0 \\
                  0 \\
                  0 \\
                  0 \\
                  0
          \end{bmatrix} , \; \; \;
\Delta_2 = \begin{bmatrix}
                  0 \\
                  -1 \\
                  0 \\
                  0 \\
                  0 \\
                  0 \\
                  0
          \end{bmatrix} , \; \; \;
\Delta_3 = \begin{bmatrix}
                  -1 \\
                  0 \\
                  +1 \\
                  0 \\
                  0 \\
                  0 \\
                  0
          \end{bmatrix}   , \; \; \;
\Delta_4 = \begin{bmatrix}
                  0 \\
                  0 \\
                  -1 \\
                  +1 \\
                  +1 \\
                  0 \\
                  0
          \end{bmatrix}  , \; \; \;
\Delta_5 = \begin{bmatrix}
                  0 \\
                  0 \\
                  0 \\
                  -1 \\
                  -1 \\
                  +1 \\
                  0
          \end{bmatrix} , \; \; \;
\Delta_6 = \begin{bmatrix}
                  0 \\
                  0 \\
                  0 \\
                  0 \\
                  0 \\
                  -1 \\
                  +1
          \end{bmatrix}      
\end{align}

##Distinct Molecular Reactant Combinations ( $\vec{h}$ )


> $h_\mu$ := number of distinct $R_\mu$ molecular reactant combinations available in the state ($X[1], \cdots, X[7]$) ($\mu= 1, \cdots, 6$)

***NOTE: $h_\mu$ is dependent on the coefficients of the species in the reaction.
We currently have assumed that all coefficients $c_{i,j} = 1$ ***

\begin{align}
  h_1 &= g \\
  h_2 &= b \\
  h_3 &= g \\
  h_4 &= e \\
  h_5 &= e_5 \cdot e_{5,22} \\
  h_6 &= p
\end{align}

##Initial Reaction Constants ( $\vec{c}$ )

> $c_\mu$ := probability that reaction $R_\mu$ will occur

$$
  \vec{c}_0 = \begin{bmatrix}
              \sigma_1 \\
              \sigma_2 \\
              \alpha \\
              \beta \\
              \gamma \\
              \varphi 
            \end{bmatrix}
$$

#The Modification

The key concept of the modification of the Gillespie method is to update the reaction rate constants as the environment of the reaction changes.

[List of environment parameters]
*   pH of the solution
*   [affects of high concentration or low concentration] 
*   ATP, ADP, energy ? etc

## pH

# Python - Stochastic Simulation

## Prep the Python environment
"""

# PREP THE PYTHON ENVIRONMENT
import sys
import matplotlib.pyplot as plt
import numpy as np
from scipy.integrate import odeint
import cmath

"""##Original Gillespie Simulation

###Gillespie
"""

def gillespie(x, c, delta):

  # Initalize iteration counter and time within the function. (Want to reduce the number of parameters we have to pass into the funtion.)
  iter = 0
  time = 0

  #  Initalize an array to store all updates in species concetrantions and their corresponding time. 
  history_x = [x]
  history_t =[time]

  while time <= runtime:
    # Define/update the array storing the distinct molecular reactant combinations
    h = ([ x[0],
           x[1],
           x[0],
           x[2],
           x[3] * x[4],
           x[5] ])
    
    # Define/update the array storing the probability of each reaction firing
    a = ([ h[0]*c[0],
           h[1]*c[1],
           h[2]*c[2],
           h[3]*c[3],
           h[4]*c[4],
           h[5]*c[5] ])

    # Get a random number pair for r1 and r2 to calculate tau and mu
    (r1, r2) = random_pair()

    # Calculate tau
    tau = (1 / sum(a) ) * np.log(1 / r1)

    # Increment time by tau
    time = time + tau

    # Create/update the history of time
    history_t.append(time)

    # This value is needed to determine which reaction will be fired
    val = r2 * sum(a)

    # Call the helper function to determine which reaction will fire
    rxn = rxn_fire(val, a)

    # Adjust the concentration of molecules based on the reaction that has fired
    x = np.add(x, delta[rxn])

    # Create/update the history of x
    history_x.append(x)

    # Increment the iteration count
    iter = iter + 1

    # This is the added modification to the Gillespie simulation

  # The end of the simulation
  return(history_x, history_t)

"""### Helper Functions"""

# Generate two random numbers from uniform distribution (0,1)
def random_pair():
  x = np.random.uniform(0, 1)
  y = np.random.uniform(0, 1)

  return(x, y)

# Determine which reaction has fired
def rxn_fire(val, a):
  sum_list = [sum(a)]

  for i in range(len(a)):
    sum_list.append(sum(a[:i+1]))
    print(sum_list)
  
  sum_list.append(val)
  sum_list.sort()
  rxn = sum_list.index(val)

  return(rxn)

# Plot the results
# x = [glu, bio, erg, erg5, erg22, pro, goal]
def plot_results(history_x, history_t):
  glu_vec = []
  bio_vec = []
  erg_vec = []
  erg5_vec = []
  erg22_vec = []
  pro_vec = []
  goal_vec = []

  for i in range( len(history_x) ):
      glu_vec.append( history_x[i][0] )
      bio_vec.append( history_x[i][1] )
      erg_vec.append( history_x[i][2] )
      erg5_vec.append( history_x[i][3] )
      erg22_vec.append( history_x[i][4] )
      pro_vec.append( history_x[i][5] )
      goal_vec.append( history_x[i][6] )

  plt.title('Time vs. Species Concentration')
  plt.xlabel('time')
  plt.ylabel('species concentration')
  plt.plot(history_t, goal_vec, color='red', label='Progesterone')
  plt.legend()
  plt.show()

"""### User Inputs

\begin{align}  
    \vec{X}_0 &= \begin{bmatrix}
            g \\
            b \\
            e \\
            e_5 \\
            e_{5,22} \\
            p \\
            p^*
    \end{bmatrix}
              \xrightarrow{\;\;\; \text{In Python} \;\;\;} \begin{bmatrix}
                                              \text{glu} \\
                                              \text{bio} \\
                                              \text{erg}\\
                                              \text{erg5} \\
                                              \text{erg22} \\
                                              \text{pro} \\
                                              \text{goal}
                                        \end{bmatrix} \\
    \vec{c}_0 &= \begin{bmatrix}
              \sigma_1 \\
              \sigma_2 \\
              \alpha \\
              \beta \\
              \gamma \\
              \varphi 
            \end{bmatrix}
          \xrightarrow{\;\;\; \text{In Python} \;\;\;} \begin{bmatrix}
                                              \text{sig1} \\
                                              \text{sig2} \\
                                              \text{alpha}\\
                                              \text{beta} \\
                                              \text{gamma} \\
                                              \text{phi}
                                        \end{bmatrix} \\
    \Delta &= \begin{bmatrix}
            \Delta_1, \Delta_2, \Delta_3, \Delta_4, \Delta_5, \Delta_6 
        \end{bmatrix}
      \xrightarrow{\;\;\; \text{In Python} \;\;\;} \begin{bmatrix}
                                          \text{del1} , \text{del2} , \text{del3} , \text{del4} , \text{del5} , \text{del6} 
                                    \end{bmatrix}
  \end{align}

### Run Simulation
"""

def Driver():
#-----------------------------USER INPUTS------------------------------------
  # Enter the initial molecular concentrations:
  glu = 
  bio = 
  erg =
  erg5 =
  erg22 = 
  pro =
  goal = 

  # Enter the initial reaction constants:
  sig1 =
  sig2 =
  alpha =
  beta = 
  gamma = 
  phi =

  # Enter the concentration changes for each reaction, starting with reaction 1:
  del1 = [-1, 1, 0, 0, 0, 0, 0]
  del2 = [0, -1, 0, 0, 0, 0, 0]
  del3 = [-1, 0, 1, 0, 0, 0, 0]
  del4 = [0, 0, -1, 1, 1, 0, 0]
  del5 = [0, 0, 0, -1, -1, 1, 0]
  del6 = [0, 0, 0, 0, 0, -1, 1]

  # How many seconds would you like the simulation to run for?
  runtime = 30
#----------------------------------------------------------------------------

  # Compile the arrays needed in the program
  x = [glu, bio, erg, erg5, erg22, pro, goal]
  c = [sig1, sig2, alpha, beta, gamma, phi]
  delta = [del1, del2, del3, del4, del5, del6]

  # Run Gillespie simulation
  (history_x, history_t) = gillespie(c, x, delta)
  plot_results(history_x, history_t)

Driver()

"""## Modified Gillespie Simulation

###Pseudo-code
"""

# Gillespie: stochastic simulation (one reaction at a time)

  Input:
    time
    iter
    rate constants
    species concentration
  Output:
    updated species concentration
    which rxn fired
    iteration
    time

# env_energy: maintains energy environment
  Initial energy-species concentration

  Input:
    which rxn fired
  Output:
    updated energy-species concentration
## If we run out of at least one species, then should we terminate. Or should we make that reaction rate 0. This may lead to an infinite loop. 
## We should just do an OR statement termination. (concentration of progesterone OR time limit reached)

# mod_energy: modifies rate constants WRT energy-species concentration

  Input:
    energy-species concentration (or species concentration)
    rate constants
  Output:
    updated rate constants
## If proportion of current ATP vs total possible ATP is large, then sigma 2 will increase. 

# # env_ph: maintains ph level/environment
#   Initial pH level

#   Input:
#     species concentration
#     which rxn fired
#   Output:
#     updated pH level
# ## If pH levels get to high or low, then should we terminate. Or should we make that reaction rate 0. This may lead to an infinite loop. 
# ## We should just do an OR statement termination. (concentration of progesterone OR time limit reached)


# # mod_ph: modifies rate constants WRT pH level

#   Input:
#     pH level
#     rate constants
#   Output:
#     updated rate constants


# history: records history of all 

  Input:
    rate constant, species concentration, rxn firings, time, energy-species concentration, ph level
  Output:
    array of all of the above captured at each iteration

## DRIVER: driver function will contain all functions and terminate based on a termination criteria

  (Input) Termination criteria:
    progesterone concentration
    (start with time criteria to avoide endless loop; just in case we never hit our progesterone criteria)
  Output:
    results

"""### Modified Gillespie

"""

def mod_gillespie(x, c, delta, iter, time):

    # Define/update the array storing the distinct molecular reactant combinations
    h = ([ x[0],
           x[1],
           x[0],
           x[2],
           x[3] * x[4],
           x[5] ])
    
    # Define/update the array storing the probability of each reaction firing
    a = ([ h[0]*c[0],
           h[1]*c[1],
           h[2]*c[2],
           h[3]*c[3],
           h[4]*c[4],
           h[5]*c[5] ])

    # Get a random number pair for r1 and r2 to calculate tau and mu
    (r1, r2) = random_pair()

    # Calculate tau
    tau = (1 / sum(a) ) * np.log(1 / r1)

    # Increment time by tau
    time = time + tau

    # This value is needed to determine which reaction will be fired
    val = r2 * sum(a)

    # Call the helper function to determine which reaction will fire
    rxn = rxn_fire(val, a)

    # Adjust the concentration of molecules based on the reaction that has fired
    x = np.add(x, delta[rxn])

    # Increment the iteration count
    iter = iter + 1

  # The end of the simulation
  return(x, iter, time, rxn)

"""###Energy"""

def env_energy(rxn, x_energy):

  return(x_energy)

def mod_energy(c, x_energy)

  return(c)

"""###Run Simulation"""

def Driver():
#-----------------------------USER INPUTS------------------------------------
  # Enter the initial reaction constants:
  sig1 =
  sig2 =
  alpha =
  beta = 
  gamma = 
  phi =

  # Enter the initial molecular concentrations:
  glu = 
  bio = 
  erg =
  erg5 =
  erg22 = 
  pro =
  goal = 

  # Enter the concentration changes for each reaction, starting with reaction 1:
  del1 = [-1, 1, 0, 0, 0, 0, 0]
  del2 = [0, -1, 0, 0, 0, 0, 0]
  del3 = [-1, 0, 1, 0, 0, 0, 0]
  del4 = [0, 0, -1, 1, 1, 0, 0]
  del5 = [0, 0, 0, -1, -1, 1, 0]
  del6 = [0, 0, 0, 0, 0, -1, 1]

  # Enter the initial energy cocentrations:
  atp = 
  adp = 
  nadp = 
  nadph = 

  # Enter initial pH level:
  ph = 

  # How many seconds would you like the simulation to run for?
  runtime = 30
#----------------------------------------------------------------------------

  # Compile the arrays needed in the program
  c = [sig1, sig2, alpha, beta, gamma, phi]
  x = [glu, bio, erg, erg5, erg22, pro, goal]
  delta = [del1, del2, del3, del4, del5, del6]
  x_energy = [atp, adp, nadp, nadph]

  # Run Gillespie simulation
  (history_x, history_t) = gillespie(c, x, delta)
  plot_results(history_x, history_t)

"""## Gillespie w/ Energy

"""

def gillespie_energy(x, c, delta):

  # Initalize iteration counter and time within the function. (Want to reduce the number of parameters we have to pass into the funtion.)
  iter = 0
  time = 0

  #  Initalize an array to store all updates in species concetrantions and their corresponding time. 
  history_x = [x]
  history_t =[time]

  while time <= runtime: #or progesterone = 45 (mass: 314 g/mol)
    # Define/update the array storing the distinct molecular reactant combinations
    h = ([ x[0],
           x[1],
           x[0] * x[7] * (x[10]*(x[10]-1)*0.5),
           x[2] * x[10],
           x[3] * x[4] * x[10],
           x[5] ])
    
    # Define/update the array storing the probability of each reaction firing
    a = ([ h[0]*c[0],
           h[1]*c[1],
           h[2]*c[2],
           h[3]*c[3],
           h[4]*c[4],
           h[5]*c[5] ])

    # Get a random number pair for r1 and r2 to calculate tau and mu
    (r1, r2) = random_pair()

    # Calculate tau
    tau = (1 / sum(a) ) * np.log(1 / r1)

    # Increment time by tau (~ms)
    time = time + tau

    # Create/update the history of time
    history_t.append(time)

    # This value is needed to determine which reaction will be fired
    val = r2 * sum(a)

    # Call the helper function to determine which reaction will fire
    rxn = rxn_fire(val, a)

    # Adjust the concentration of molecules based on the reaction that has fired
    x = np.add(x, delta[rxn])

    # Create/update the history of x
    history_x.append(x)

    # Increment the iteration count
    iter = iter + 1

    # This is the added modification to the Gillespie simulation

  # The end of the simulation
  return(history_x, history_t)

def Driver():
#-----------------------------USER INPUTS------------------------------------
  # Enter the initial molecular concentrations: (# of molecules(as molar mass))
  # micromolar M per mol; mol=moles/L
  glu = 100 #0
  bio = 0 #1
  erg = 0 #2
  erg5 = 0 #3
  erg22 = 0 #4
  pro = 0 #5
  goal = 0 #6
  atp = 50 #7(+1 biomass +50 atp)
  adp = 50 #8 (not relevant)
  nadp = 50 #9
  nadph = 50 #10

  # Enter the initial reaction constants:
  sig1 = 1 #growth
  sig2 = 0.5 #death
  alpha = 2 #higher
  beta = 0.30 #similar to phi
  gamma = 0.05 #less likely than beta and phi 
  phi = 0.33

  # Enter the concentration changes for each reaction, starting with reaction 1:
  del1 = [-1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  del2 = [0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  del3 = [-1, 0, 1, 0, 0, 0, 0, -1, 1, -2, 2]
  del4 = [0, 0, -1, 1, 1, 0, 0, 0, 0, 1, -1]
  del5 = [0, 0, 0, -1, -1, 1, 0, 0, 0, 1, -1]
  del6 = [0, 0, 0, 0, 0, -1, 1, 0, 0, 0, 0]

  # How many seconds would you like the simulation to run for?
  runtime = 30
#----------------------------------------------------------------------------

  # Compile the arrays needed in the program
  x = [glu, bio, erg, erg5, erg22, pro, goal, atp, adp, nadp, nadph]
  c = [sig1, sig2, alpha, beta, gamma, phi]
  delta = [del1, del2, del3, del4, del5, del6]

  # Run Gillespie simulation
  (history_x, history_t) = gillespie(c, x, delta)
  plot_results(history_x, history_t)
